COMPILER Tastier // 

   const int // types
      undef = 0, integer = 1, boolean = 2,str = 3;

   const int // object kinds
      var = 0, proc = 1 , scope = 2 , arr = 3,record = 4,recvar = 5, recarr = 6;
  const int 
      mutable = 0, immutable = 1;

   public SymbolTable   tab;
   public CodeGenerator gen;
  
/*--------------------------------------------------------------------------*/
CHARACTERS
letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  						
// ---------------------//AN----------------------------
  tab = '\t'.
  space = ' '.
  other = "+\\!\"£$%^&*()_-=[];'#/.,<>?:@~}{".
  str_char = letter + digit + space + tab + other .
 //END ---------------------//AN---------------------------- 

TOKENS
  ident  = letter {letter | digit}.
  number = digit {digit}.
  string = '\"' {str_char} '\"' . //AN
  
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS
/*------------------------------------------------------------------------*/
AddOp<out Op op>
=                        (. op = Op.ADD; .)
  ( '+'
  | '-'                  (. op = Op.SUB; .)
  ).
/*----------------------------------//AN------------------------------------*/
ArrayDecl<int kind,string rec>       (. int type; string name;Obj obj;int dim = 0; .) 
= "array" 
    Type<out type>               (.if(type != integer 
                                     && type != boolean)SemErr("array must be of int or boolean type"); .)
    Ident<out name>              (. obj = tab.NewObj(name,kind,type,rec); .)

    "[" Expr<out type> "]"       (. if(type != integer)SemErr("array index must be of int type"); 
                                    dim++; .)
    { "[" Expr<out type> "]"     (. if(type != integer)SemErr("array index must be of int type");
                                    dim++; .)
    } ";"                       (. gen.Emit(Op.HPTR); 
                                    if (obj.level == 0) gen.Emit(Op.STOG, obj.adr);
                                        else gen.Emit(Op.STO, tab.curLevel-obj.level, obj.adr); 
                                    gen.Emit(Op.HPTR);
                                    gen.Emit(Op.ALLOCARR,dim);  obj.dimN = dim; .)
.
/*----------------------------------//AN------------------------------------*/
ConstVarDecl<int kind,string rec>  (. string name; int type; Obj obj; .)
= "const" Ident<out name>	(. obj = tab.NewConstVar(name,kind,rec);  .)
	":=" 
	Expr<out type>		(. tab.assignType(obj,type); 
				  if (obj.level == 0) gen.Emit(Op.STOG, obj.adr);
				    else gen.Emit(Op.STO, tab.curLevel-obj.level, obj.adr); .)
	';'.
/*END--------------------------------AN--------------------------------------*/
Expr<out int type>       (. int type1; Op op; .)
= SimExpr<out type>
  [ RelOp<out op>
    SimExpr<out type1>   (. if (type != type1) SemErr("incompatible types");
                            gen.Emit(op); type = boolean; .)
  ].
/*------------------------------------------------------------------------*/
Factor<out int type>     (. int n; Obj obj,obj2; string name; int dim = 0;bool rec_access = false;.)
=                        (. type = undef; .)
( Ident<out name>      (. obj = tab.Find(name,""); type = obj.type;
                            if(obj.kind == scope || obj.kind == proc)
                                SemErr("object must be an array or a variable");
                          .)
[
    "."                     (. if(obj.kind != record) SemErr("LHS of the dot must be a record name"); .)
    Ident<out name>      (. obj2 = tab.Find(name,obj.name); type = obj2.type; 
                             if(obj2.kind != recvar)
                               SemErr("RHS of the dot must be a var belonging to the record on the LHS");
                             if(obj2.record_name != obj.name)
                               SemErr("var RHS of the dot must belong to the record on the LHS");
                               obj = obj2; rec_access = true;.)

    |
        "[" Expr<out type> "]"       (. if(type != integer)SemErr("array index must be of int type"); 
                                    dim++; .)
        { "[" Expr<out type> "]"   (. if(type != integer)SemErr("array index must be of int type"); 
                                    dim++; .)
        }                          (. if(dim != obj.dimN)SemErr("number of dimensions do not match"); .)

    |  
        "->"                         (. if(obj.kind != record) SemErr("LHS of the dot must be a record name"); .)
        Ident<out name>      (. obj2 = tab.Find(name,obj.name); type = obj2.type; 
                             if(obj2.kind != recarr)
                               SemErr("RHS of the arrow must be an array belonging to the record on the LHS");
                             if(obj2.record_name != obj.name)
                               SemErr("RHS of the arrow must be an array of the record on the LHS");
                               obj = obj2; rec_access = true;.)
         
        "[" Expr<out type> "]"     (. if(type != integer)SemErr("array index must be of int type"); 
                                    dim++; .)
        { "[" Expr<out type> "]" (. if(type != integer)SemErr("array index must be of int type"); 
                                    dim++; .)
        }                       (. if(dim != obj.dimN)SemErr("number of dimensions do not match"); .)

]                     (.if((obj.kind == recvar || obj.kind == recarr) && !rec_access)
                                SemErr("object belongs to a record. Maybe prepend the record name?"); .)

                            (.if (obj.level == 0) gen.Emit(Op.LOADG, obj.adr);
                                  else gen.Emit(Op.LOAD, tab.curLevel-obj.level, obj.adr); 
                              if(obj.kind == recarr) gen.Emit(Op.ACCARR);
                              if( obj.type == str) gen.Emit(Op.STRINGR);
                              .)
                              

  | number               (. n = Convert.ToInt32(t.val); 
                            gen.Emit(Op.CONST, n); type = integer; .)
  | '-'
    Factor<out type>     (. if (type != integer) {
                               SemErr("integer type expected"); type = integer;
                            }
                            gen.Emit(Op.NEG); .)
  | "true"               (. gen.Emit(Op.CONST, 1); type = boolean; .)
  | "false"              (. gen.Emit(Op.CONST, 0); type = boolean; .)
  | string		  		 (. for(int ch = t.val.Length-1; ch >= 1; ch--){
                                gen.Emit(Op.CONST,t.val[ch]);
                            }
                            gen.Emit(Op.CONST,t.val.Length-2);
                            type = str; .)  //AN
  ).
/*------------------------------------------------------------------------*/
Ident<out string name>
= ident                  (. name = t.val; .).
/*------------------------------------------------------------------------*/
MulOp<out Op op>
=                        (. op = Op.MUL; .)
  ( '*'
  | '/'                  (. op = Op.DIV; .)
  ).
/*------------------------------------------------------------------------*/
ProcDecl                 (. string name; Obj obj; int adr, adr2; .)         // 
= "void"
  Ident<out name>        (. obj = tab.NewObj(name, proc, undef,""); obj.adr = gen.pc;
                            if (name == "Main") {                           // 
                               obj.level= 0; gen.progStart = gen.pc;        // 
                            }                                               // 
                               else obj.level = tab.curLevel+1;             // 
                            tab.OpenScope(name); .)
  '(' ')'
  '{'                    (. gen.Emit(Op.ENTER, 0); adr = gen.pc - 2; .)
  { ConstVarDecl<var,""> | VarDecl<var,""> | Stat | ArrayDecl<arr,"">	 //AN
                        			  (. gen.Emit(Op.JMP, 0); adr2 = gen.pc - 2; .)      // 
    ProcDecl             (. gen.Patch(adr2, gen.pc); .)                     // 
  }                                                                         // 
  '}'                    (. gen.Emit(Op.LEAVE); gen.Emit(Op.RET);
                            gen.Patch(adr, tab.topScope.nextAdr);

                            Console.WriteLine("name\t|kind\t|type\t|lev\t|mut\t|addr");
                            Console.WriteLine("----------------------------------------------\n");
                            tab.CloseScope(); .).
/*------------------------------------------------------------------------*/
Record              (.string name;  .)
=
 "record" Ident<out name>(. tab.NewObj(name,record,undef,""); 
                                .)
  
  '{'                    
 {( VarDecl<recvar,name>
   |
   ArrayDecl<recarr,name>
   )}
 "}"                       (.
                             .)

.

/*------------------------------------------------------------------------*/
RelOp<out Op op>
=                        (. op = Op.EQU; .) 
  ( '='										 //AN
  | '<'                  (. op = Op.LSS; .)
  | '>'                  (. op = Op.GTR; .)
  | "!="                  (. op = Op.NEQ; .) //AN
  | "<="                  (. op = Op.LSE; .) //AN
  | ">="                  (. op = Op.GTE; .) //AN
  ).
/*------------------------------------------------------------------------*/
SimExpr<out int type>    (. int type1; Op op; .)
= Term<out type>
  { AddOp<out op>
    Term<out type1>      (. if (type != integer || type1 != integer) 
                               SemErr("integer type expected");
                            gen.Emit(op); .)
  }.

/*------------------------------------------------------------------------*/
Switch                          (.int type,type1,caseaddr;
                                    Obj dummy = tab.NewObj("sw" + tab.nextUnused(),0,undef,"");
                                    System.Collections.Generic.List<int> breakaddrs
                                    = new System.Collections.Generic.List<int>();.)
= "switch" 
    "(" Expr<out type> ")"       (.if(type != integer) SemErr("must have int type in case expr");
                                    if (dummy.level == 0) gen.Emit(Op.STOG, dummy.adr);
                                    else gen.Emit(Op.STO, tab.curLevel-dummy.level, dummy.adr);.)
    "{"
    { "case" Expr<out type1>    (.if(type1 != type) SemErr("case type must match switch type");
                                  if (dummy.level == 0) gen.Emit(Op.LOADG, dummy.adr);
                                    else gen.Emit(Op.LOAD, tab.curLevel-dummy.level, dummy.adr); 
                                  gen.Emit(Op.EQU); gen.Emit(Op.FJMP,0);caseaddr = gen.pc - 2; .)
        ":"
        [Stat]
        ["break"                   (. gen.Emit(Op.JMP,0); breakaddrs.Add(gen.pc-2);
                                      gen.Patch(caseaddr,gen.pc); .)
        ]
    }
    [   "default" ":" 
        [Stat]
        ["break"                   (.gen.Emit(Op.JMP,0); breakaddrs.Add(gen.pc-2); .)
        ]
    ]
    "}"                         (. foreach(int addr in breakaddrs) gen.Patch(addr,gen.pc); .)
    .


/*------------------------------------------------------------------------*/
Stat                     	(. int type,type1,type2; string name; Obj obj,obj2;
								int adr, adr2, loopstart,assg_start; int dim = 0;
								bool rec_access = false;.)
= Ident<out name>        	(. obj = tab.Find(name,""); .)
( 
  ["->"                   (. if(obj.kind != record) SemErr("LHS of the dot must be a record name"); .)
   Ident<out name>     (. obj2 = tab.Find(name,obj.name); type = obj2.type; 
                             if(obj2.kind != recarr)
                               SemErr("RHS of the arrow  must be an array record object");
                             if(obj2.record_name != obj.name)
                               SemErr("RHS of the arrow must belong to the record on the LHS");
                               obj = obj2;rec_access = true;.)
  ]
                                (.if(obj.kind == recarr && !rec_access)
                                SemErr("object belongs to a record. Maybe prepend the record name?"); .)

  
  

    "[" Expr<out type> "]"      (.if(type != integer)SemErr("array index must be of int type"); 
                                    dim++; .) 
    { "[" Expr<out type> "]"    (. if(type != integer)SemErr("array index must be of int type"); 
                                    dim++; .)
    }                          (. if(dim != obj.dimN)SemErr("number of dimensions do not match"); .)

    ":="                    (. .) 
    Expr<out type>          (.if (obj.level == 0) gen.Emit(Op.LOADG, obj.adr);
                                  else gen.Emit(Op.LOAD, tab.curLevel-obj.level, obj.adr); 
                              gen.Emit(Op.ASSGARR); .)

    ";"
  |
  [ "."                  (. if(obj.kind != record) SemErr("LHS of the dot must be a record name"); .)
     Ident<out name>      (. obj2 = tab.Find(name,obj.name); type = obj2.type; 
                             if(obj2.kind != recvar)
                               SemErr("RHS of the dot must be a var record object");
                             if(obj2.record_name != obj.name)
                               SemErr("RHS of the dot must belong to the record on the LHS");
                               obj = obj2;rec_access = true;.)
 ]                         (.if(obj.kind == recvar && !rec_access)
                                SemErr("object belongs to a record. Maybe prepend the record name?"); .)
  ":="                    
    Expr<out type>        (.if(type != obj.type) SemErr("types do not match");.)
    (';'                 (.       
                            
                            if( type == str) gen.Emit(Op.HPTR);
                            
                            if (obj.level == 0) gen.Emit(Op.STOG, obj.adr);
                               else gen.Emit(Op.STO, tab.curLevel-obj.level, obj.adr);
                            if(type == str){
                                gen.Emit(Op.HPTR);gen.Emit(Op.STRINGW);
                            }.) 
    | "?"                (.if(type != boolean) SemErr("Expecting boolean condition");
                         gen.Emit(Op.FJMP,0); adr = gen.pc - 2;.)
    Expr<out type1>    (.if(obj.type != type1) SemErr("incompatible types2");
                         gen.Emit(Op.JMP,0); gen.Patch(adr,gen.pc);adr = gen.pc - 2;
                         if (type1 != obj.type) SemErr("incompatible types3");
                         if (obj.level == 0) gen.Emit(Op.STOG, obj.adr);
                         else gen.Emit(Op.STO, tab.curLevel-obj.level, obj.adr); .) 
    ":"
    Expr<out type2>     (.if(obj.type != type2) SemErr("incompatible types4");
                         gen.Patch(adr,gen.pc);
                         if (type2 != obj.type) SemErr("incompatible types5");
                         if (obj.level == 0) gen.Emit(Op.STOG, obj.adr);
                         else gen.Emit(Op.STO, tab.curLevel-obj.level, obj.adr); .) 
    ";")
  

    

  | '(' ')' ';'          (. if (obj.kind != proc) SemErr("object is not a procedure");
                               gen.Emit(Op.CALL, obj.level-tab.curLevel, obj.adr); .)     // 
  )

| "if" 
  '(' Expr<out type> ')' (. if (type != boolean) SemErr("boolean type expected");
                               gen.Emit(Op.FJMP, 0); adr = gen.pc - 2; .)
      Stat
      [ "else"           (. gen.Emit(Op.JMP, 0); adr2 = gen.pc - 2;
                            gen.Patch(adr, gen.pc); adr = adr2; .)
        Stat 
      ]                  (. gen.Patch(adr, gen.pc); .)

| "while"                (. loopstart = gen.pc; .)
  '(' Expr<out type> ')' (. if (type != boolean) SemErr("boolean type expected");
                               gen.Emit(Op.FJMP, 0); adr = gen.pc - 2; .)
      Stat               (. gen.Emit(Op.JMP, loopstart); gen.Patch(adr, gen.pc); .)

| "for"                 
  "(" Ident<out name>    (. obj = tab.Find(name,""); .)
   ":=" Expr<out type> ";" (.if(type != obj.type) SemErr("incompatible types");
                             if (obj.level == 0) gen.Emit(Op.STOG, obj.adr);
                             else gen.Emit(Op.STO, tab.curLevel-obj.level, obj.adr); 
                                gen.Emit(Op.JMP,0);assg_start = gen.pc-2; loopstart = gen.pc;.)
   Ident<out name>       (.obj2 = tab.Find(name,""); .)  
   ":=" Expr<out type1> ";"     (. if(type1 != obj2.type) SemErr("incompatible types");
                                  if (obj.level == 0) gen.Emit(Op.STOG, obj.adr);
                                  else gen.Emit(Op.STO, tab.curLevel-obj.level, obj.adr);
                                  gen.Patch(assg_start,gen.pc);.)
   Expr<out type2>      (.if(type2 != boolean) SemErr("expecting boolean conditional");
                            gen.Emit(Op.FJMP,0); adr = gen.pc - 2;.)
 
   ")" "{"
   Stat                     (.gen.Emit(Op.JMP,loopstart); gen.Patch(adr,gen.pc); .)
   "}"
| Switch

| "read"
  Ident<out name> ';'    (. obj = tab.Find(name,"");
                            if (obj.type != integer) SemErr("integer type expected");
                               gen.Emit(Op.READ);
                            if (obj.level == 0) gen.Emit(Op.STOG, obj.adr);
//                             else gen.Emit(Op.STO, obj.adr); .)                            ***
                               else gen.Emit(Op.STO, tab.curLevel-obj.level, obj.adr); .) // 

| "write" 
  Expr<out type>      	(. 	if(type == str) gen.Emit(Op.SWRITE);					//AN
                            else if(type == integer) gen.Emit(Op.WRITE);		//AN
								else SemErr("expected type int or string"); .)		//AN
								
  {"," Expr<out type> (. 	if(type == str) gen.Emit(Op.SWRITE); 					//AN
                            else if(type == integer) gen.Emit(Op.WRITE);		//AN
								else SemErr("expected type int or string"); .)		//AN
  } ';'  					(.gen.Emit(Op.NEWLINE);.)								//AN
| '{' { Stat | VarDecl<var,""> | ConstVarDecl<var,""> | ArrayDecl<arr,"">} '}' .
/*------------------------------------------------------------------------*/
Tastier                  (. string name; .) // 
= "program"
  Ident<out name>        (. tab.OpenScope(name); .)
  '{'
  { Record | ConstVarDecl<var,""> | VarDecl<var,""> | ProcDecl | ArrayDecl<arr,"">  }  //AN
  '}'                    (. tab.CloseScope();
                            if (gen.progStart == -1) SemErr("main function never defined");
                         .).
/*------------------------------------------------------------------------*/
Term<out int type>       (. int type1; Op op; .)
= Factor<out type>
  { MulOp<out op>
    Factor<out type1>    (. if (type != integer || type1 != integer) 
                               SemErr("integer type expected");
                            gen.Emit(op); .)
  }.
/*------------------------------------------------------------------------*/
Type<out int type>
=                        (. type = undef; .)
 ( "int"                 (. type = integer; .)
 | "bool"                (. type = boolean; .)
 | "string"                (. type = str; .) //AN
 ).
/*------------------------------------------------------------------------*/
VarDecl<int kind,string rec>  (. string name; int type; .)
= Type<out type>
  Ident<out name>        (. tab.NewObj(name, kind, type,rec); .)
  { ',' Ident<out name>  (. tab.NewObj(name, kind, type,rec); .)
  } ';'.

END Tastier. // 
