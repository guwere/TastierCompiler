using System;using System.IO;using System.Text;namespace Tastier {   public enum Op { // opcodes   ADD, SUB, MUL, DIV, EQU, LSS, GTR, NEG,    NEQ, LSE, GTE, // AN   LOAD, LOADG, STO, STOG, CONST,   CALL, RET, ENTER, LEAVE, JMP, FJMP, READ, WRITE,   STRING,SWRITE,NEWLINE //AN   }public class CodeGenerator {      string[] opcode =      {"ADD  ", "SUB  ", "MUL  ", "DIV  ", "EQU  ", "LSS  ", "GTR  ", "NEG  ","NEQ  ","LSE  ", "GTE  ", //AN       "LOAD ", "LOADG", "STO  ", "STOG ", "CONST ", "CALL ", "RET  ", "ENTER",       "LEAVE", "JMP  ", "FJMP ", "READ ", "WRITE","STRING ","SWRITE ","NEWLINE"}; //AN   public int progStart; // address of first instruction of main program   public int pc;        // program counter   byte[] code = new byte[3000];   // data for Interpret   int[] globals = new int[100];      const int max = 1000;       // maximum number of elements on runtime stack    int[] stack = new int[max]; // increase stack size to allow more recursion       int top; // top of stack      int bp;  // base pointer   public CodeGenerator() {      pc = 1; progStart = -1;   }   //----- code generation methods -----      public void Put(int x) {      code[pc++] = (byte)x;   }      public void Emit (Op op) {      Put((int)op);   }   public void Emit (Op op, int val) {      Emit(op); Put(val>>8); Put(val);   }   //------------------------//AN----------------------------	public void EmitStr(string s){		Emit(Op.STRING);		byte[] array = Encoding.ASCII.GetBytes(s);		int slen = array.Length;		Put(slen-2);		for(int i = 1; i < slen - 1; i++){			Put((int)array[i]);		}	}//END ---------------------//AN----------------------------// method to generate LOAD, STORE and ENTER instructions   // which include an extra lexic level difference parameter    public void Emit (Op op, int level, int val) {       //       Emit(op); Put(level); Put(val>>8); Put(val);      //    }     //    public void Patch (int adr, int val) {      code[adr] = (byte)(val>>8); code[adr+1] = (byte)val;   }   public void Decode() {       int maxPc = pc;      pc = 1;      while (pc < maxPc) {         Op code = (Op)Next();         Console.Write("{0,3}: {1} ", pc-1, opcode[(int)code]);         switch(code) {            case Op.LOAD: case Op.STO: case Op.CALL:                 //                Console.WriteLine("{0} {1}", Next(), Next2()); break; //             case Op.LOADG: case Op.CONST: case Op.STOG:              //             case Op.ENTER: case Op.JMP: case Op.FJMP:                //                Console.WriteLine(Next2()); break;            case Op.ADD: case Op.SUB: case Op.MUL: case Op.DIV: case Op.NEG: 			case Op.NEQ: case Op.LSE: case Op.GTE: //AN            case Op.EQU: case Op.LSS: case Op.GTR: case Op.RET: case Op.LEAVE:             case Op.READ: case Op.WRITE: case Op.SWRITE: case Op.NEWLINE: //AN               Console.WriteLine(); break;			   // ---------------------//AN----------------------------			case Op.STRING:				int slen = Next();				int slen2 = slen;				string s="";				while(slen > 0){ slen--; s = s + (char)Next();}				Console.WriteLine("{0} len: {1}",s,slen2);				break;				//END ---------------------//AN----------------------------			         }      }   }   //----- interpreter methods -----      int Next () {      return code[pc++];   }   int Next2 () {      int x,y;       x = (sbyte)code[pc++]; y = code[pc++];      return (x << 8) + y;   }   int Int (bool b) {      if (b) return 1; else return 0;   }   int Push (int val) {      if (top < max) stack[top++] = val;             //          else throw new Exception("stack overflow"); //       return val;   }   int Pop() {      return stack[--top];   }   int ReadInt(FileStream s) {      int ch, sign;      do {ch = s.ReadByte();} while (!(ch >= '0' && ch <= '9' || ch == '-'));      if (ch == '-') {sign = -1; ch = s.ReadByte();} else sign = 1;      int n = 0;      while (ch >= '0' && ch <= '9') {         n = 10 * n + (ch - '0');         ch = s.ReadByte();      }      return n * sign;   }// stack frame layout and pointer locations:                 //                                                           //       *                         *                         // top ->*                         *                         //       * local variables         *                         //       ***************************                         //       * dynamic link (dl)       *                         //       * static link (sl)        *                         //       * lexic level delta (lld) *                         // bp -> * return address          *                         //       ***************************                         //                                                           // dl  - bp of calling procedure's frame for popping stack   // sl  - bp of enclosing procedure for addressing variables  // lld - ll difference (delta) between a called procedure    //       and its calling procudure                               public void printStack(){        Console.WriteLine("bottom------");        for (int i = 0; i < stack.Length; i++) {            Console.WriteLine((char)stack[i]);        }        Console.WriteLine("top-----------");    }   public void Interpret (string data) {       int val;      int i, j; // 	  int slen,slen2; //AN      try {         FileStream s = new FileStream(data, FileMode.Open);         Console.WriteLine();                  pc = progStart; stack[0] = 0; top = 2; bp = 0; //          stack[1] = 0; // outermost lexic level delta                        for (;;) {         switch ((Op)Next()) {				// ---------------------//AN----------------------------			   case Op.STRING:			       string temp = "";							slen = Next();							slen2 = slen;							while(slen > 0){								slen--;								temp += (char)Push(Next());							}							Push(slen2);							break;									case Op.SWRITE:					//		printStack();							slen = Pop();							string str="";							while(slen > 0){								slen--;								str = (char)Pop() + str;							}							Console.Write(str); 							break;								   case Op.NEWLINE: Console.WriteLine();  break;			   //END ---------------------//AN----------------------------               case Op.CONST: Push(Next2()); break;                                          // base address for variable is                               // i levels down static link chain                case Op.LOAD:  i = Next(); j = bp;          //                               while (i > 0) {              //                                  i--; j = stack[j+2];      //                               }                            //                               i = j+Next2()+4;             //                               Push(stack[i]); break;       //                case Op.LOADG: Push(globals[Next2()]); break;                                          // base address for variable is                               // i levels down static link chain                case Op.STO:   i = Next(); j = bp;          //                               while (i > 0) {              //                                  i--; j = stack[j+2];      //                               }                            //                               i = j+Next2()+4;             //                               stack[i] = Pop(); break;     //                                              case Op.STOG:  globals[Next2()] = Pop(); break;               case Op.ADD:   Push(Pop()+Pop()); break;               case Op.SUB:   Push(-Pop()+Pop()); break;               case Op.DIV:   val = Pop(); Push(Pop()/val); break;               case Op.MUL:   Push(Pop()*Pop()); break;               case Op.NEG:   Push(-Pop()); break;               case Op.EQU:   Push(Int(Pop()==Pop())); break;               case Op.NEQ:   Push(Int(Pop()!=Pop())); break;               case Op.LSE:   Push(Int(Pop()<=Pop())); break;               case Op.GTE:   Push(Int(Pop()>=Pop())); break;               case Op.LSS:   Push(Int(Pop()>Pop())); break;               case Op.GTR:   Push(Int(Pop()<Pop())); break;               case Op.JMP:   pc = Next2(); break;               case Op.FJMP:  val = Next2(); if (Pop()==0) pc = val; break;               case Op.READ:  val = ReadInt(s); Push(val); break;               case Op.WRITE: Console.Write(Pop()); break; //AN                           // call instruction includes byte containing                                    // difference in lexic level between called and                                 // calling procedures; call instruction pushes                                  // return address and lexic level delta                             case Op.CALL:  Push(pc+3); Push(Next()); pc = Next2(); break; //                               case Op.RET:   pc = Pop(); if (pc == 0) return; break;                           // top points to new frame's static link field                      case Op.ENTER: i = stack[top-1];  // load lexic level delta                                    stack[top+1] = bp; // store dynamic link                                        j = bp;            // load caller's static link                              // if called procedure is at same lexic level as                                // calling procedure then its static link is a copy                             // of its calling procedure's static link                                          if (i == 0) stack[top] = stack[j+2];           //                                  else {                                      //                               // otherwise called procedure's static link is a                                // copy of the static link found "i" levels down                                // the static link chain                                                              while (i > 1) {                          //                                        i--; j = stack[j+2];                  //                                     }                                        //                                     stack[top] = j; // store static link     //                                  }                                           //                               bp = top-2; top = top+Next2()+2;               //                               break;                                         //                            // reset bp from frame's dynamic link field                                              case Op.LEAVE: top = bp+1; bp = stack[top+2];        //                               break;                              default:       throw new Exception("illegal opcode");            }         }      } catch (IOException) {         Console.WriteLine("--- Error accessing file {0}", data);         System.Environment.Exit(0);      }   }} // end CodeGenerator} // end namespace