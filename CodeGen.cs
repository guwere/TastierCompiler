using System; using System.IO;using System.Text;using System.Collections.Generic;namespace Tastier {    public enum Op { // opcodes        ADD, SUB, MUL, DIV, EQU, LSS, GTR, NEG,             NEQ, LSE, GTE, // AN            LOAD, LOADG, STO, STOG, CONST,            CALL, RET, ENTER, LEAVE, JMP, FJMP, READ, WRITE,            STRINGW,STRINGR,NEWLINE,ALLOCARR ,ASSGARR,HPTR,ACCARR,            SWRITE//AN    }    public class CodeGenerator {        string[] opcode =        {"ADD  ","SUB  ","MUL  ", "DIV  ","EQU  ","LSS  ","GTR  ","NEG  ","NEQ  ","LSE  ", "GTE  ", //AN            "LOAD ", "LOADG", "STO  ", "STOG ", "CONST ", "CALL ", "RET  ", "ENTER",            "LEAVE", "JMP  ", "FJMP ", "READ ", "WRITE",            "STRINGW","STRINGR","NEWLINE","ALLOCARR","ASSGARR","HPTR","ACCARR",             "SWRITE"}; //AN        public int progStart; // address of first instruction of main program        public int pc;        // program counter        byte[] code = new byte[3000];        // data for Interpret        int[] globals = new int[100];        const int max = 1000;       // maximum number of elements on runtime stack         int[] stack = new int[max]; // increase stack size to allow more recursion         int top; // top of stack        int bp;  // base pointer        const int max_heap = 10000;        int [] heap = new int [max_heap];        int heapptr;        public int getHeapPtr(){return heapptr;}        public CodeGenerator() {            pc = 1; progStart = -1;            heapptr = 0;        }        //----- code generation methods -----        public void Put(int x) {            code[pc++] = (byte)x;        }        public void Emit (Op op) {            Put((int)op);        }        public void Emit (Op op, int val) {            Emit(op); Put(val>>8); Put(val);        }             // method to generate LOAD, STORE and ENTER instructions           // which include an extra lexic level difference parameter         public void Emit (Op op, int level, int val) {       //             Emit(op); Put(level); Put(val>>8); Put(val);      //         }     //         public void Patch (int adr, int val) {            code[adr] = (byte)(val>>8); code[adr+1] = (byte)val;        }        public void Decode() {             int maxPc = pc;            pc = 1;            while (pc < maxPc) {                Op code = (Op)Next();                Console.Write("{0,3}: {1} ", pc-1, opcode[(int)code]);                switch(code) {                    case Op.LOAD: case Op.STO: case Op.CALL:  //                         Console.WriteLine("{0} {1}", Next(), Next2()); break; //                     case Op.LOADG: case Op.CONST: case Op.STOG:              //                     case Op.ENTER: case Op.JMP: case Op.FJMP: case Op.ALLOCARR:                        Console.WriteLine(Next2()); break;                    case Op.ADD: case Op.SUB: case Op.MUL: case Op.DIV: case Op.NEG:                     case Op.NEQ: case Op.LSE: case Op.GTE: //AN                    case Op.EQU: case Op.LSS: case Op.GTR: case Op.RET: case Op.LEAVE:                     case Op.READ: case Op.WRITE:  case Op.NEWLINE:                    case Op.HPTR: case Op.ASSGARR: case Op.ACCARR: case Op.STRINGW:                     case Op.STRINGR: case Op.SWRITE:                        Console.WriteLine(); break;                }            }        }        public int getHeapOffset(int currptr){            int dim = heap[currptr++];            int [] dim_sizes = new int[dim];            int [] dim_offsets = new int [dim];            for(int i = 0; i < dim; ++i){                dim_sizes[i] = heap[currptr++];                int reverse_i = dim - i - 1;                dim_offsets[reverse_i] = Pop();                if(dim_offsets[reverse_i] > dim_sizes[i] - 1)                    throw new Exception("array out of bounds above maximum");                if(dim_offsets[reverse_i] < 0)                    throw new Exception("array out bounds below 0");            }            int off = flattenIndex(dim_offsets,dim_sizes);            return currptr+off;        }        public int flattenIndex(int []dim_offs,int []dim_sizes ){            int l = dim_offs.Length;            int index = 0;            for(int i = 0; i < l - 1; ++i){                int p = dim_offs[i];                for(int j = i + 1; j < l; ++j){                    p = p * dim_sizes[j];                }                index += p;            }            index += dim_offs[l - 1];            return index;        }        //----- interpreter methods -----        int Next () {            return code[pc++];        }        int Next2 () {            int x,y;             x = (sbyte)code[pc++]; y = code[pc++];            return (x << 8) + y;        }        int Int (bool b) {            if (b) return 1; else return 0;        }        int Push (int val) {            if (top < max) stack[top++] = val;             //             else throw new Exception("stack overflow"); //             return val;        }        int Pop() {            return stack[--top];        }        int ReadInt(FileStream s) {            int ch, sign;            do {ch = s.ReadByte();} while (!(ch >= '0' && ch <= '9' || ch == '-'));            if (ch == '-') {sign = -1; ch = s.ReadByte();} else sign = 1;            int n = 0;            while (ch >= '0' && ch <= '9') {                n = 10 * n + (ch - '0');                ch = s.ReadByte();            }            return n * sign;        }        public void printStack(){            Console.WriteLine("bottom------");            for (int i = 0; i < top; i++) {                Console.WriteLine((char)(stack[i]+ '0'));            }            Console.WriteLine("top-----------");        }        // stack frame layout and pointer locations:                         //                                                                   //       *                         *                                 // top ->*                         *                                 //       * local variables         *                                 //       ***************************                                 //       * dynamic link (dl)       *                                 //       * static link (sl)        *                                 //       * lexic level delta (lld) *                                 // bp -> * return address          *                                 //       ***************************                                 //                                                                   // dl  - bp of calling procedure's frame for popping stack           // sl  - bp of enclosing procedure for addressing variables          // lld - ll difference (delta) between a called procedure            //       and its calling procudure                                   public void Interpret (string data) {             int val;            int i, j; //             int slen; //AN            int dim,arrsize,n,currptr;            int [] dims;            string outstr = "";            try {                FileStream s = new FileStream(data, FileMode.Open);                Console.WriteLine();                pc = progStart; stack[0] = 0; top = 2; bp = 0; //                 stack[1] = 0; // outermost lexic level delta                      for (;;) {                    Op opc = (Op)Next();                    string opcs = opcode[(int)opc];                    Console.WriteLine("{current read op} :" +opcs); //debugging purposes                    switch (opc) {                        // ---------------------//AN----------------------------                        case Op.STRINGW: currptr = Pop();                                         slen = Pop();                                         heap[currptr++] = slen;                                         for(i = 0 ; i < slen; ++i){                                             heap[currptr++] = Pop();                                         }                                         break;                        case Op.STRINGR: currptr = Pop();                                         slen = heap[currptr];                                         for(i = slen; i >= 1; --i){                                             Push(heap[currptr+i]);                                         }                                         Push(slen);                                         break;                        case Op.SWRITE:  slen = Pop();                                         for (i = 0; i < slen; i++) {                                             outstr += (char)Pop();                                         }                                         Console.Write(outstr);                                         outstr = "";                                         break;                        case Op.NEWLINE: Console.WriteLine();  break;                        case Op.HPTR : Push(heapptr);break;                        case Op.ALLOCARR: heapptr = Pop();                                          dim = Next2();                                           dims = new int[dim];                                          arrsize = 1;                                          for (n = dim - 1; n >=0; n--) {                                              dims[n] = Pop();                                              arrsize = arrsize * dims[n];                                          }                                          heap[heapptr++] = dim;                                          for (int n1 = 0; n1 < dim; n1++) {                                              heap[heapptr++] = dims[n1];                                          }                                          heapptr = heapptr + arrsize;                                          Console.WriteLine("{codegen}heap size : " + heapptr);                                          break;                        case Op.ASSGARR: currptr = Pop();                                         val = Pop();                                         currptr = getHeapOffset(currptr);                                         heap[currptr] = val;                                         break;                        case Op.ACCARR: currptr = Pop();                                        currptr = getHeapOffset(currptr);                                        Push(heap[currptr]);                                        break;                                        //END ---------------------//AN----------------------------                        case Op.CONST: Push(Next2()); break;                                       // base address for variable is                                           // i levels down static link chain                         case Op.LOAD:  i = Next(); j = bp;          //                                        while (i > 0) {              //                                            i--; j = stack[j+2];      //                                        }                            //                                        i = j+Next2()+4;             //                                        Push(stack[i]); break;       //                         case Op.LOADG: Push(globals[Next2()]); break;                                       // base address for variable is                                           // i levels down static link chain                         case Op.STO:   i = Next(); j = bp;          //                                        while (i > 0) {              //                                            i--; j = stack[j+2];      //                                        }                            //                                        i = j+Next2()+4;             //                                        stack[i] = Pop(); break;     //                         case Op.STOG:  globals[Next2()] = Pop(); break;                        case Op.ADD:   Push(Pop()+Pop()); break;                        case Op.SUB:   Push(-Pop()+Pop()); break;                        case Op.DIV:   val = Pop(); Push(Pop()/val); break;                        case Op.MUL:   Push(Pop()*Pop()); break;                        case Op.NEG:   Push(-Pop()); break;                        case Op.EQU:   Push(Int(Pop()==Pop())); break;                        case Op.NEQ:   Push(Int(Pop()!=Pop())); break;                        case Op.LSE:   Push(Int(Pop()<=Pop())); break;                        case Op.GTE:   Push(Int(Pop()>=Pop())); break;                        case Op.LSS:   Push(Int(Pop()>Pop())); break;                        case Op.GTR:   Push(Int(Pop()<Pop())); break;                        case Op.JMP:   pc = Next2(); break;                        case Op.FJMP:  val = Next2(); if (Pop()==0) pc = val; break;                        case Op.READ:  val = ReadInt(s); Push(val); break;                        case Op.WRITE: Console.Write(Pop()); break; //AN                                       // call instruction includes byte containing                                                // difference in lexic level between called and                                             // calling procedures; call instruction pushes                                              // return address and lexic level delta                                      case Op.CALL:  Push(pc+3); Push(Next()); pc = Next2(); break; //                         case Op.RET:   pc = Pop();if (pc == 0) return; break;                                       // top points to new frame's static link field                               case Op.ENTER: i = stack[top-1];  // load lexic level delta                                             stack[top+1] = bp; // store dynamic link                                                 j = bp;            // load caller's static link                                          // if called procedure is at same lexic level as                                            // calling procedure then its static link is a copy                                         // of its calling procedure's static link                                                   if (i == 0) stack[top] = stack[j+2];           //                                        else {                                      //                                            // otherwise called procedure's static link is a                                             // copy of the static link found "i" levels down                                             // the static link chain                                                                     while (i > 1) {                          //                                                i--; j = stack[j+2];                  //                                            }                                        //                                            stack[top] = j; // store static link     //                                        }                                           //                                        bp = top-2; top = top+Next2()+2;               //                                        break;                                         //                                        // reset bp from frame's dynamic link field                                                       case Op.LEAVE: top = bp+1; bp = stack[top+2];        //                                        break;                        default:       throw new Exception("illegal opcode");                    }                }            } catch (IOException) {                Console.WriteLine("--- Error accessing file {0}", data);                System.Environment.Exit(0);            }        }    } // end CodeGenerator} // end namespace