using System; using System.IO;using System.Text;using System.Collections.Generic;namespace Tastier {//AN+    public enum Op { // opcodes        ADD, SUB, MUL, DIV, EQU, LSS, GTR, NEG,             NEQ, LSE, GTE, // AN            LOAD, LOADG, STO, STOG, CONST,            CALL, RET, ENTER, LEAVE, JMP, FJMP, READ, WRITE,            STRINGW,STRINGR,NEWLINE,ALLOCARR ,ASSGARR,HPTR,ACCARR,            SWRITE,NOP    }    public class CodeGenerator {//AN+        string[] opcode =        {"ADD  ","SUB  ","MUL  ", "DIV  ","EQU  ","LSS  ","GTR  ","NEG  ","NEQ  ","LSE  ", "GTE  ",             "LOAD ", "LOADG", "STO  ", "STOG ", "CONST ", "CALL ", "RET  ", "ENTER",            "LEAVE", "JMP  ", "FJMP ", "READ ", "WRITE",            "STRINGW","STRINGR","NEWLINE","ALLOCARR","ASSGARR","HPTR","ACCARR",             "SWRITE","NOP"};         public int progStart; // address of first instruction of main program        public int pc;        // program counter        byte[] code = new byte[3000];        // data for Interpret        int[] globals = new int[100];        const int max = 1000;       // maximum number of elements on runtime stack         int[] stack = new int[max]; // increase stack size to allow more recursion         int top; // top of stack        int bp;  // base pointer//AN++        const int max_heap = 10000;        int [] heap = new int [max_heap];        int heapptr;//AN        public CodeGenerator() {            pc = 1; progStart = 1;            heapptr = 0;        }        //----- code generation methods -----        public void Put(int x) {            code[pc++] = (byte)x;        }        public void Emit (Op op) {            Put((int)op);        }        public void Emit (Op op, int val) {            Emit(op); Put(val>>8); Put(val);        }             // method to generate LOAD, STORE and ENTER instructions(and some other)           // which include an extra lexic level difference parameter         public void Emit (Op op, int level, int val) {       //             Emit(op); Put(level); Put(val>>8); Put(val);      //         }     //         public void Patch (int adr, int val) {            code[adr] = (byte)(val>>8); code[adr+1] = (byte)val;        }//AN++//      use to replace triple NOP instruction at code[adr] with JMP val.//      where the NOPs are inserted just above each procedure declaration.//      courtesy of how the progStart is now handled: it start from the beginning (pc = 1) and not [pc]:Main//      so to avoid going in procedures there are uncoditional jumps just before each procedure//      except "Main" that is patched to jump just after the procedure declaration.//      This was needed so arrays can be properly declared inside Records.        public void PatchInstruction(int adr , Op op, int val){            code[adr++] = (byte)op; Patch(adr,val);        }//AN++        public void Decode() {             int maxPc = pc;            pc = 1;            while (pc < maxPc) {                Op code = (Op)Next();                Console.Write("{0,3}: {1} ", pc-1, opcode[(int)code]);                switch(code) {                    case Op.LOAD: case Op.STO: case Op.CALL:  //                         Console.WriteLine("{0} {1}", Next(), Next2()); break; //                     case Op.LOADG: case Op.CONST: case Op.STOG:              //                     case Op.ENTER: case Op.JMP: case Op.FJMP: case Op.ALLOCARR:                        Console.WriteLine(Next2()); break;                    case Op.ADD: case Op.SUB: case Op.MUL: case Op.DIV: case Op.NEG:                     case Op.NEQ: case Op.LSE: case Op.GTE: //AN                    case Op.EQU: case Op.LSS: case Op.GTR: case Op.RET: case Op.LEAVE:                     case Op.READ: case Op.WRITE:  case Op.NEWLINE:                    case Op.HPTR: case Op.ASSGARR: case Op.ACCARR: case Op.STRINGW:                     case Op.STRINGR: case Op.SWRITE: case Op.NOP:                         Console.WriteLine(); break;                }            }        }//AN++/*@param currptr - the pointer pointing to the start of the array structure in the heap@return - the exact pointer in the heap where a value is to be assigned or read from the array expects the array offsets to be sitting on the stack one after the other with the right most on the top. the array structure in the heap is as follows: dim_no | S1 |.... | Sn | I0 | I1 | .... | I(S1*...*Sn) | where dim_no is the number dimensions S1 is the left most dimension Sn is the right most dimension Ij is the index in the array currptr is pointing to dim_no Also the procedure checks for array out of bounds*/        public int getHeapOffset(int currptr){            int dim = heap[currptr++];            int [] dim_sizes = new int[dim];            int [] dim_offsets = new int [dim];            for(int i = 0; i < dim; ++i){                dim_sizes[i] = heap[currptr++];                int reverse_i = dim - i - 1;                dim_offsets[reverse_i] = Pop();                if(dim_offsets[i] > dim_sizes[i] - 1){                    Console.WriteLine("offset :" +  dim_offsets[reverse_i]);                    Console.WriteLine("size :" +  dim_sizes[i] );                    throw new Exception("array out of bounds above maximum"); }                if(dim_offsets[reverse_i] < 0)                    throw new Exception("array out bounds below 0");            }            int off = flattenIndex(dim_offsets,dim_sizes);            return currptr+off;        }//AN++/*@param dim_offs - an array with the array offsets       dim_sizes - an array with the array dimension sizes@return - multidimensional array offset converted to single array offsetgiven S0,...,Sn and O0,...,On then     single = (sigma[a=0 to n-1] of (Oa * product[b=a+1 to n] of Sb)) + On     if you write it out on paper it's a lot clearer. */        public int flattenIndex(int []dim_offs,int []dim_sizes ){            int l = dim_offs.Length;            int index = 0;            for(int i = 0; i < l - 1; ++i){                int p = dim_offs[i];                for(int j = i + 1; j < l; ++j){                    p = p * dim_sizes[j];                }                index += p;            }            index += dim_offs[l - 1];            return index;        }        //----- interpreter methods -----        int Next () {            return code[pc++];        }        int Next2 () {            int x,y;             x = (sbyte)code[pc++]; y = code[pc++];            return (x << 8) + y;        }        int Int (bool b) {            if (b) return 1; else return 0;        }        int Push (int val) {            if (top < max) stack[top++] = val;             //             else throw new Exception("stack overflow"); //             return val;        }        int Pop() {            return stack[--top];        }        int ReadInt(FileStream s) {            int ch, sign;            do {ch = s.ReadByte();} while (!(ch >= '0' && ch <= '9' || ch == '-'));            if (ch == '-') {sign = -1; ch = s.ReadByte();} else sign = 1;            int n = 0;            while (ch >= '0' && ch <= '9') {                n = 10 * n + (ch - '0');                ch = s.ReadByte();            }            return n * sign;        }//AN++ debugging purposes        public void printStack(){            Console.WriteLine("bottom------");            for (int i = 0; i < top; i++) {                Console.WriteLine((char)(stack[i]+ '0'));            }            Console.WriteLine("top-----------");        }        // stack frame layout and pointer locations:                         //                                                                   //       *                         *                                 // top ->*                         *                                 //       * local variables         *                                 //       ***************************                                 //       * dynamic link (dl)       *                                 //       * static link (sl)        *                                 //       * lexic level delta (lld) *                                 // bp -> * return address          *                                 //       ***************************                                 //                                                                   // dl  - bp of calling procedure's frame for popping stack           // sl  - bp of enclosing procedure for addressing variables          // lld - ll difference (delta) between a called procedure            //       and its calling procudure                           //AN++        public void Interpret (string data) {             int val;            int i, j;              int slen;             int dim,arrsize,n,currptr;            int [] dims;            string outstr = "";            try {                FileStream s = new FileStream(data, FileMode.Open);                Console.WriteLine();                pc = progStart; stack[0] = 0; top = 2; bp = 0; //                 stack[1] = 0; // outermost lexic level delta                      for (;;) {                    Op opc = (Op)Next();                  //  Console.WriteLine("{current op} :"  + opc); //debugging purposes                    switch (opc) {                        //no operation performed                        case Op.NOP : break;                         //current heap pointer/size  for array and string declarations                        case Op.HPTR : Push(heapptr);break;                        //writes on the heap as many items from the stack to the heap as                         // the size of slen after it writes slen                        // starting at location pointed to by currptr                        case Op.STRINGW: currptr = Pop();                                         slen = Pop();                                         heap[currptr++] = slen;                                         for(i = 0 ; i < slen; ++i){                                             heap[currptr++] = Pop();                                         }                                         break;                        //reads from the heap as many items(chars) as the size of thefirst value                         //on the heap and pushes each one of the stack in reverse order                         //and after that the length of the string                        case Op.STRINGR: currptr = Pop();                                         slen = heap[currptr];                                         for(i = slen; i >= 1; --i){                                             Push(heap[currptr+i]);                                         }                                         Push(slen);                                         break;                        // takes as many characters from the stack as the size of the top of the stack                        // and prints them out to the console                        case Op.SWRITE:  slen = Pop();                                         for (i = 0; i < slen; i++) {                                             outstr += (char)Pop();                                         }                                         Console.Write(outstr);                                         outstr = "";                                         break;                        //insert a new line after each call to "write"                        case Op.NEWLINE: Console.WriteLine();  break;                        //expects the current heap pointer to be on top of the stack                        //        the number of dimensions to have been Emitted after the opcode                        //        the individual dimensions of the array pushed on the stack with                        //          the right most on the top                        //writes to the heap contigously in the following format                        //      dim_no | S1 |.... | Sn | I0 | I1 | .... | I(S1*...*Sn) |                        //where I0...I(s1*...*Sn) are left as zeroes                        //      from dim_no to I(S1*...*Sn) is the total size needed to represent the array                        //updates the heap size/pointer to point just after the last index of the array                        case Op.ALLOCARR: heapptr = Pop();                                          dim = Next2();                                           dims = new int[dim];                                          arrsize = 1;                                          for (n = dim - 1; n >=0; n--) {                                              dims[n] = Pop();                                              arrsize = arrsize * dims[n];                                          }                                          heap[heapptr++] = dim;                                          for (int n1 = 0; n1 < dim; n1++) {                                              heap[heapptr++] = dims[n1];                                          }                                          heapptr = heapptr + arrsize;                                          Console.WriteLine("{codegen}heap size : " + heapptr); // debugging                                           break;                        //expects the pointer of the array object to be on top of the stack                        //        the value of a calculated expression next                        //        the offsets within the array right most on top                        //        the procedure getHeapOffset internally pops of offsets                        //           and calculates the absolute offset within the heap                        case Op.ASSGARR: currptr = Pop();                                         val = Pop();                                         currptr = getHeapOffset(currptr);                                         heap[currptr] = val;                                         break;                        // same as above except it writes from the heap to the stack                        // a particular value                        case Op.ACCARR: currptr = Pop();                                        currptr = getHeapOffset(currptr);                                        Push(heap[currptr]);                                        break;                        case Op.CONST: Push(Next2()); break;                                       // base address for variable is                                           // i levels down static link chain                         case Op.LOAD:  i = Next(); j = bp;          //                                        while (i > 0) {              //                                            i--; j = stack[j+2];      //                                        }                            //                                        i = j+Next2()+4;             //                                        Push(stack[i]); break;       //                         case Op.LOADG: Push(globals[Next2()]); break;                                       // base address for variable is                                           // i levels down static link chain                         case Op.STO:   i = Next(); j = bp;          //                                        while (i > 0) {              //                                            i--; j = stack[j+2];      //                                        }                            //                                        i = j+Next2()+4;             //                                        stack[i] = Pop(); break;     //                         case Op.STOG:  globals[Next2()] = Pop(); break;                        case Op.ADD:   Push(Pop()+Pop()); break;                        case Op.SUB:   Push(-Pop()+Pop()); break;                        case Op.DIV:   val = Pop(); Push(Pop()/val); break;                        case Op.MUL:   Push(Pop()*Pop()); break;                        case Op.NEG:   Push(-Pop()); break;                        case Op.EQU:   Push(Int(Pop()==Pop())); break;                        case Op.NEQ:   Push(Int(Pop()!=Pop())); break;                        case Op.LSE:   Push(Int(Pop()<=Pop())); break;                        case Op.GTE:   Push(Int(Pop()>=Pop())); break;                        case Op.LSS:   Push(Int(Pop()>Pop())); break;                        case Op.GTR:   Push(Int(Pop()<Pop())); break;                        case Op.JMP:   pc = Next2(); break;                        case Op.FJMP:  val = Next2(); if (Pop()==0) pc = val; break;                        case Op.READ:  val = ReadInt(s); Push(val); break;                        case Op.WRITE: Console.Write(Pop()); break; //AN                                       // call instruction includes byte containing                                                // difference in lexic level between called and                                             // calling procedures; call instruction pushes                                              // return address and lexic level delta                                      case Op.CALL:  Push(pc+3); Push(Next()); pc = Next2(); break; //                         case Op.RET:   pc = Pop();if (pc == 0) return; break;                                       // top points to new frame's static link field                               case Op.ENTER: i = stack[top-1];  // load lexic level delta                                             stack[top+1] = bp; // store dynamic link                                                 j = bp;            // load caller's static link                                          // if called procedure is at same lexic level as                                            // calling procedure then its static link is a copy                                         // of its calling procedure's static link                                                   if (i == 0) stack[top] = stack[j+2];           //                                        else {                                      //                                            // otherwise called procedure's static link is a                                             // copy of the static link found "i" levels down                                             // the static link chain                                                                     while (i > 1) {                          //                                                i--; j = stack[j+2];                  //                                            }                                        //                                            stack[top] = j; // store static link     //                                        }                                           //                                        bp = top-2; top = top+Next2()+2;               //                                        break;                                         //                                        // reset bp from frame's dynamic link field                                                       case Op.LEAVE: top = bp+1; bp = stack[top+2];        //                                        break;                        default:       throw new Exception("illegal opcode");                    }                }            } catch (IOException) {                Console.WriteLine("--- Error accessing file {0}", data);                System.Environment.Exit(0);            }        }    } // end CodeGenerator} // end namespace